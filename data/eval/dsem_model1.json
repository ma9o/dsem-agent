{
  "latent": {
    "constructs": [
      {
        "name": "error_resolution_speed",
        "description": "How quickly errors/bugs are identified and fixed - the primary outcome measuring debugging efficiency",
        "role": "endogenous",
        "is_outcome": true,
        "temporal_status": "time_varying",
        "causal_granularity": "hourly"
      },
      {
        "name": "developer_experience_level",
        "description": "Overall programming experience and seniority - accumulated knowledge from years in the field",
        "role": "exogenous",
        "is_outcome": false,
        "temporal_status": "time_invariant",
        "causal_granularity": null
      },
      {
        "name": "domain_expertise",
        "description": "Deep knowledge of the specific business domain and problem space",
        "role": "exogenous",
        "is_outcome": false,
        "temporal_status": "time_invariant",
        "causal_granularity": null
      },
      {
        "name": "system_architecture_complexity",
        "description": "Inherent complexity of the software system's design and interdependencies",
        "role": "exogenous",
        "is_outcome": false,
        "temporal_status": "time_invariant",
        "causal_granularity": null
      },
      {
        "name": "error_complexity",
        "description": "The inherent difficulty of the current error - whether it's a simple typo or deep architectural issue",
        "role": "endogenous",
        "is_outcome": false,
        "temporal_status": "time_varying",
        "causal_granularity": "hourly"
      },
      {
        "name": "external_interruptions",
        "description": "Disruptions from meetings, messages, notifications, or colleague questions",
        "role": "exogenous",
        "is_outcome": false,
        "temporal_status": "time_varying",
        "causal_granularity": "hourly"
      },
      {
        "name": "sleep_quality",
        "description": "Quality and duration of sleep affecting next-day cognitive performance",
        "role": "exogenous",
        "is_outcome": false,
        "temporal_status": "time_varying",
        "causal_granularity": "daily"
      },
      {
        "name": "test_coverage_confidence",
        "description": "Confidence from existing tests that changes won't introduce regressions",
        "role": "exogenous",
        "is_outcome": false,
        "temporal_status": "time_varying",
        "causal_granularity": "weekly"
      },
      {
        "name": "documentation_quality",
        "description": "Availability and usefulness of documentation for understanding the system",
        "role": "exogenous",
        "is_outcome": false,
        "temporal_status": "time_varying",
        "causal_granularity": "weekly"
      },
      {
        "name": "cognitive_clarity",
        "description": "Mental sharpness, focus, and absence of fatigue enabling clear thinking",
        "role": "endogenous",
        "is_outcome": false,
        "temporal_status": "time_varying",
        "causal_granularity": "hourly"
      },
      {
        "name": "stress_level",
        "description": "Current psychological stress from deadlines, pressure, or workload",
        "role": "endogenous",
        "is_outcome": false,
        "temporal_status": "time_varying",
        "causal_granularity": "daily"
      },
      {
        "name": "flow_state",
        "description": "State of deep focus and immersion in the debugging task",
        "role": "endogenous",
        "is_outcome": false,
        "temporal_status": "time_varying",
        "causal_granularity": "hourly"
      },
      {
        "name": "codebase_familiarity",
        "description": "Current understanding of the specific codebase, its patterns, and quirks",
        "role": "endogenous",
        "is_outcome": false,
        "temporal_status": "time_varying",
        "causal_granularity": "daily"
      },
      {
        "name": "error_diagnosis_efficiency",
        "description": "Ability to quickly identify the root cause of an error",
        "role": "endogenous",
        "is_outcome": false,
        "temporal_status": "time_varying",
        "causal_granularity": "hourly"
      },
      {
        "name": "fix_implementation_efficiency",
        "description": "Speed and accuracy of coding the solution once the problem is understood",
        "role": "endogenous",
        "is_outcome": false,
        "temporal_status": "time_varying",
        "causal_granularity": "hourly"
      },
      {
        "name": "code_quality",
        "description": "Readability, maintainability, and organization of the codebase",
        "role": "endogenous",
        "is_outcome": false,
        "temporal_status": "time_varying",
        "causal_granularity": "weekly"
      },
      {
        "name": "debugging_tool_proficiency",
        "description": "Skill in using debugging tools, profilers, and log analysis systems",
        "role": "endogenous",
        "is_outcome": false,
        "temporal_status": "time_varying",
        "causal_granularity": "weekly"
      }
    ],
    "edges": [
      {
        "cause": "error_diagnosis_efficiency",
        "effect": "error_resolution_speed",
        "description": "Quickly identifying the root cause directly enables faster overall resolution",
        "lagged": false
      },
      {
        "cause": "fix_implementation_efficiency",
        "effect": "error_resolution_speed",
        "description": "Faster implementation of the fix directly speeds up resolution",
        "lagged": false
      },
      {
        "cause": "error_complexity",
        "effect": "error_resolution_speed",
        "description": "More complex errors take longer to resolve regardless of skill",
        "lagged": false
      },
      {
        "cause": "flow_state",
        "effect": "error_resolution_speed",
        "description": "Being in flow enables faster, more effective debugging",
        "lagged": false
      },
      {
        "cause": "cognitive_clarity",
        "effect": "error_resolution_speed",
        "description": "Mental clarity enables better problem-solving and faster resolution",
        "lagged": false
      },
      {
        "cause": "codebase_familiarity",
        "effect": "error_diagnosis_efficiency",
        "description": "Knowing the codebase helps quickly narrow down where bugs might be",
        "lagged": true
      },
      {
        "cause": "debugging_tool_proficiency",
        "effect": "error_diagnosis_efficiency",
        "description": "Skilled use of debuggers and profilers speeds diagnosis",
        "lagged": true
      },
      {
        "cause": "documentation_quality",
        "effect": "error_diagnosis_efficiency",
        "description": "Good documentation helps understand expected behavior and find discrepancies",
        "lagged": true
      },
      {
        "cause": "error_complexity",
        "effect": "error_diagnosis_efficiency",
        "description": "Complex errors with multiple interacting causes are harder to diagnose",
        "lagged": false
      },
      {
        "cause": "code_quality",
        "effect": "error_diagnosis_efficiency",
        "description": "Clean, readable code is easier to debug and trace",
        "lagged": true
      },
      {
        "cause": "cognitive_clarity",
        "effect": "error_diagnosis_efficiency",
        "description": "Clear thinking enables pattern recognition and logical deduction",
        "lagged": false
      },
      {
        "cause": "developer_experience_level",
        "effect": "error_diagnosis_efficiency",
        "description": "Experienced developers recognize error patterns and common pitfalls faster",
        "lagged": true
      },
      {
        "cause": "domain_expertise",
        "effect": "error_diagnosis_efficiency",
        "description": "Domain knowledge helps identify when behavior deviates from business requirements",
        "lagged": true
      },
      {
        "cause": "codebase_familiarity",
        "effect": "fix_implementation_efficiency",
        "description": "Knowing where and how to make changes speeds implementation",
        "lagged": true
      },
      {
        "cause": "test_coverage_confidence",
        "effect": "fix_implementation_efficiency",
        "description": "Confidence in tests allows faster changes without fear of regressions",
        "lagged": true
      },
      {
        "cause": "code_quality",
        "effect": "fix_implementation_efficiency",
        "description": "Well-structured code is easier to modify safely",
        "lagged": true
      },
      {
        "cause": "flow_state",
        "effect": "fix_implementation_efficiency",
        "description": "Flow state enables rapid, confident coding",
        "lagged": false
      },
      {
        "cause": "domain_expertise",
        "effect": "fix_implementation_efficiency",
        "description": "Understanding the domain helps implement correct solutions",
        "lagged": true
      },
      {
        "cause": "external_interruptions",
        "effect": "flow_state",
        "description": "Interruptions break flow and prevent deep focus",
        "lagged": false
      },
      {
        "cause": "cognitive_clarity",
        "effect": "flow_state",
        "description": "Mental clarity is a prerequisite for achieving flow",
        "lagged": false
      },
      {
        "cause": "stress_level",
        "effect": "flow_state",
        "description": "High stress prevents the relaxed focus needed for flow",
        "lagged": true
      },
      {
        "cause": "sleep_quality",
        "effect": "cognitive_clarity",
        "description": "Good sleep the night before enables mental sharpness",
        "lagged": true
      },
      {
        "cause": "stress_level",
        "effect": "cognitive_clarity",
        "description": "Chronic stress impairs cognitive function and focus",
        "lagged": true
      },
      {
        "cause": "external_interruptions",
        "effect": "cognitive_clarity",
        "description": "Frequent interruptions fragment attention and reduce clarity",
        "lagged": false
      },
      {
        "cause": "developer_experience_level",
        "effect": "codebase_familiarity",
        "description": "Experienced developers learn codebases faster",
        "lagged": true
      },
      {
        "cause": "domain_expertise",
        "effect": "codebase_familiarity",
        "description": "Domain knowledge accelerates understanding of code purpose",
        "lagged": true
      },
      {
        "cause": "developer_experience_level",
        "effect": "debugging_tool_proficiency",
        "description": "Experience correlates with knowing and using debugging tools well",
        "lagged": true
      },
      {
        "cause": "system_architecture_complexity",
        "effect": "error_complexity",
        "description": "Complex systems tend to produce more complex errors",
        "lagged": true
      },
      {
        "cause": "code_quality",
        "effect": "error_complexity",
        "description": "Poor code quality leads to harder-to-trace errors",
        "lagged": true
      },
      {
        "cause": "error_resolution_speed",
        "effect": "stress_level",
        "description": "Resolving errors quickly reduces accumulated stress and pressure",
        "lagged": true
      },
      {
        "cause": "error_resolution_speed",
        "effect": "codebase_familiarity",
        "description": "Successfully debugging code teaches you about the codebase",
        "lagged": true
      },
      {
        "cause": "developer_experience_level",
        "effect": "code_quality",
        "description": "Experienced developers tend to write and maintain cleaner code",
        "lagged": true
      },
      {
        "cause": "system_architecture_complexity",
        "effect": "code_quality",
        "description": "Complex systems are harder to keep clean and well-organized",
        "lagged": true
      }
    ]
  },
  "measurement": {
    "indicators": [
      {
        "name": "error_solution_visits",
        "construct": "error_resolution_speed",
        "how_to_measure": "Count [visit] entries to solution pages (Stack Overflow answers, GitHub issues with resolutions, documentation examples) that follow an error-related [search] containing 'error', 'bug', 'fix', 'exception', 'stacktrace'. Each solution visit counts as 1.",
        "measurement_granularity": "hourly",
        "measurement_dtype": "count",
        "aggregation": "sum"
      },
      {
        "name": "error_topic_transitions",
        "construct": "error_resolution_speed",
        "how_to_measure": "Count instances where error-related searches are followed by a clear topic change (user moves to unrelated activity), suggesting the error was resolved. Each transition away from an error topic counts as 1.",
        "measurement_granularity": "hourly",
        "measurement_dtype": "count",
        "aggregation": "sum"
      },
      {
        "name": "unique_error_domains",
        "construct": "error_complexity",
        "how_to_measure": "For error-related searches, count unique website domains visited (e.g., stackoverflow.com=1, github.com=1, docs.ruby-lang.org=1). Count each distinct domain only once per hour. Record 0 if no error activity.",
        "measurement_granularity": "hourly",
        "measurement_dtype": "count",
        "aggregation": "max"
      },
      {
        "name": "error_search_refinements",
        "construct": "error_complexity",
        "how_to_measure": "Count [search] entries that refine a previous error-related search (added terms, rephrased, e.g., 'ruby error' then 'ruby custom stacktrace error'). Only count refinements for error/bug searches. Record 0 if none.",
        "measurement_granularity": "hourly",
        "measurement_dtype": "count",
        "aggregation": "sum"
      },
      {
        "name": "work_to_nonwork_switches",
        "construct": "external_interruptions",
        "how_to_measure": "Count transitions where a programming entry (technical search, docs, GitHub, code-related) is immediately followed by a non-work entry (travel, entertainment, music, personal browsing). Each such transition counts as 1.",
        "measurement_granularity": "hourly",
        "measurement_dtype": "count",
        "aggregation": "sum"
      },
      {
        "name": "nonwork_entries_count",
        "construct": "external_interruptions",
        "how_to_measure": "Count non-work entries (travel like 'meteo siracusa', entertainment, music like 'bombarolo', social, personal topics) appearing in hours that also contain technical work. Each non-work entry counts as 1.",
        "measurement_granularity": "hourly",
        "measurement_dtype": "count",
        "aggregation": "sum"
      },
      {
        "name": "late_night_entries",
        "construct": "sleep_quality",
        "how_to_measure": "Count any entries with timestamps between 00:00 and 05:00. Each entry in this time window counts as 1. Record 0 if no activity in this window.",
        "measurement_granularity": "daily",
        "measurement_dtype": "count",
        "aggregation": "sum"
      },
      {
        "name": "post_midnight_activity_flag",
        "construct": "sleep_quality",
        "how_to_measure": "Binary: 1 if any entry has timestamp between 02:00 and 05:00 (indicating significantly disrupted sleep), 0 if no activity in this window.",
        "measurement_granularity": "daily",
        "measurement_dtype": "binary",
        "aggregation": "max"
      },
      {
        "name": "test_keyword_searches",
        "construct": "test_coverage_confidence",
        "how_to_measure": "Count [search] entries containing: 'test', 'spec', 'coverage', 'mock', 'stub', 'assert', 'rspec', 'jest', 'pytest', 'unittest', 'TDD'. Each matching search counts as 1. Record 0 if none.",
        "measurement_granularity": "daily",
        "measurement_dtype": "count",
        "aggregation": "sum"
      },
      {
        "name": "official_doc_visits",
        "construct": "documentation_quality",
        "how_to_measure": "Count [visit] entries to official documentation: URLs containing 'docs.', '/doc/', '/documentation/', 'readthedocs', 'wiki.haskell', 'hackage.haskell', official language sites. Each visit counts as 1.",
        "measurement_granularity": "daily",
        "measurement_dtype": "count",
        "aggregation": "sum"
      },
      {
        "name": "community_help_visits",
        "construct": "documentation_quality",
        "how_to_measure": "Count [visit] entries to community Q&A sites: stackoverflow.com, stackexchange, reddit.com/r/ for programming topics, GitHub issues/discussions. Each visit counts as 1. High counts suggest docs are insufficient.",
        "measurement_granularity": "daily",
        "measurement_dtype": "count",
        "aggregation": "sum"
      },
      {
        "name": "related_search_sequence",
        "construct": "cognitive_clarity",
        "how_to_measure": "Binary: 1 if there are 4+ consecutive [search] entries on clearly related topics (same language/framework, same problem domain), 0 if searches frequently jump between unrelated topics.",
        "measurement_granularity": "hourly",
        "measurement_dtype": "binary",
        "aggregation": "max"
      },
      {
        "name": "scattered_search_count",
        "construct": "cognitive_clarity",
        "how_to_measure": "Count instances where consecutive searches are on completely unrelated topics (e.g., 'haskell monad' followed by 'flight prices' followed by 'ruby error'). Each unrelated jump counts as 1. Record 0 if searches are coherent.",
        "measurement_granularity": "hourly",
        "measurement_dtype": "count",
        "aggregation": "sum"
      },
      {
        "name": "stress_related_searches",
        "construct": "stress_level",
        "how_to_measure": "Count [search] entries about stress-related topics: anxiety, burnout, relaxation, sleep problems, substances, or excessive escapist browsing during apparent work time. Each matching entry counts as 1.",
        "measurement_granularity": "daily",
        "measurement_dtype": "count",
        "aggregation": "sum"
      },
      {
        "name": "outside_hours_work",
        "construct": "stress_level",
        "how_to_measure": "Count programming/technical entries (code searches, documentation, GitHub) with timestamps before 07:00 or after 22:00. Each technical entry outside normal hours counts as 1.",
        "measurement_granularity": "daily",
        "measurement_dtype": "count",
        "aggregation": "sum"
      },
      {
        "name": "sustained_technical_sequence",
        "construct": "flow_state",
        "how_to_measure": "Binary: 1 if there exists a sequence of 5+ consecutive entries all related to technical/programming work with no non-work interruptions between them, 0 otherwise.",
        "measurement_granularity": "hourly",
        "measurement_dtype": "binary",
        "aggregation": "max"
      },
      {
        "name": "single_topic_hour",
        "construct": "flow_state",
        "how_to_measure": "Binary: 1 if all technical entries in the hour focus on one coherent topic (same technology, same problem), 0 if technical work spans multiple unrelated topics within the hour.",
        "measurement_granularity": "hourly",
        "measurement_dtype": "binary",
        "aggregation": "max"
      },
      {
        "name": "basic_tutorial_searches",
        "construct": "codebase_familiarity",
        "how_to_measure": "Count [search] entries indicating unfamiliarity: containing 'how to', 'what is', 'tutorial', 'beginner', 'introduction to', 'getting started', basic syntax questions. Each matching search counts as 1.",
        "measurement_granularity": "daily",
        "measurement_dtype": "count",
        "aggregation": "sum"
      },
      {
        "name": "specific_api_searches",
        "construct": "codebase_familiarity",
        "how_to_measure": "Count [search] entries for specific APIs, function names, library internals, or implementation details (e.g., 'haskell foldr implementation', 'sentry post body'). Each specific technical search counts as 1.",
        "measurement_granularity": "daily",
        "measurement_dtype": "count",
        "aggregation": "sum"
      },
      {
        "name": "searches_to_solution",
        "construct": "error_diagnosis_efficiency",
        "how_to_measure": "For each error investigation sequence, count [search] entries before reaching a solution [visit] (Stack Overflow, docs). Record the count per sequence. Record 0 if solution found immediately or no error activity.",
        "measurement_granularity": "hourly",
        "measurement_dtype": "count",
        "aggregation": "mean"
      },
      {
        "name": "quick_solution_flag",
        "construct": "error_diagnosis_efficiency",
        "how_to_measure": "Binary: 1 if any error-related [search] is followed within 2 entries by a relevant solution visit (Stack Overflow, official docs, helpful GitHub page), 0 otherwise.",
        "measurement_granularity": "hourly",
        "measurement_dtype": "binary",
        "aggregation": "max"
      },
      {
        "name": "implementation_searches",
        "construct": "fix_implementation_efficiency",
        "how_to_measure": "Count [search] entries for implementation help after diagnosis: syntax examples, API usage, 'how to implement', code snippets. Each implementation-focused search counts as 1. Record 0 if none.",
        "measurement_granularity": "hourly",
        "measurement_dtype": "count",
        "aggregation": "sum"
      },
      {
        "name": "code_example_visits",
        "construct": "fix_implementation_efficiency",
        "how_to_measure": "Count [visit] entries to pages likely containing usable code: GitHub repos/gists, Stack Overflow answers, tutorial sites, code snippet pages. Each such visit counts as 1.",
        "measurement_granularity": "hourly",
        "measurement_dtype": "count",
        "aggregation": "sum"
      },
      {
        "name": "quality_focused_searches",
        "construct": "code_quality",
        "how_to_measure": "Count [search] entries about code quality practices: 'refactor', 'best practice', 'clean code', 'design pattern', 'code review', 'linting', 'SOLID', 'code smell'. Each matching search counts as 1.",
        "measurement_granularity": "daily",
        "measurement_dtype": "count",
        "aggregation": "sum"
      },
      {
        "name": "debugging_tool_searches",
        "construct": "debugging_tool_proficiency",
        "how_to_measure": "Count [search] entries about debugging tools: 'debugger', 'breakpoint', 'profiler', 'sentry', 'logging', 'stack trace analysis', 'memory profiling', tool names (gdb, pdb, byebug, Chrome DevTools). Each counts as 1.",
        "measurement_granularity": "daily",
        "measurement_dtype": "count",
        "aggregation": "sum"
      },
      {
        "name": "debugging_doc_visits",
        "construct": "debugging_tool_proficiency",
        "how_to_measure": "Count [visit] entries to debugging/monitoring tool documentation: sentry.io, datadog, newrelic, debugger docs, profiler guides, logging framework documentation. Each visit counts as 1.",
        "measurement_granularity": "daily",
        "measurement_dtype": "count",
        "aggregation": "sum"
      }
    ]
  }
}